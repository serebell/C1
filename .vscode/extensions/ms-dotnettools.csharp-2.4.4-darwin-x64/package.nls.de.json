{
  "configuration.csharp.inlayHints.enableInlayHintsForImplicitObjectCreation": "Hinweise für die implizite Objekterstellung anzeigen",
  "configuration.csharp.inlayHints.enableInlayHintsForImplicitVariableTypes": "Hinweise für Variablen mit abgeleiteten Typen anzeigen",
  "configuration.csharp.inlayHints.enableInlayHintsForIndexerParameters": "Hinweise für Indexer anzeigen",
  "configuration.csharp.inlayHints.enableInlayHintsForLambdaParameterTypes": "Hinweise für Lambda-Parametertypen anzeigen",
  "configuration.csharp.inlayHints.enableInlayHintsForTypes": "Inlinetyphinweise anzeigen",
  "configuration.dotnet.backgroundAnalysis.analyzerDiagnosticsScope": "Ausführen der Hintergrundcodeanalyse für: (Zuvor \"omnisharp.enableRoslynAnalyzers\")",
  "configuration.dotnet.backgroundAnalysis.analyzerDiagnosticsScope.fullSolution": "Gesamte Projektmappe",
  "configuration.dotnet.backgroundAnalysis.analyzerDiagnosticsScope.none": "Keine",
  "configuration.dotnet.backgroundAnalysis.analyzerDiagnosticsScope.openFiles": "Geöffnete Dokumente",
  "configuration.dotnet.backgroundAnalysis.compilerDiagnosticsScope": "Compilerfehler und -warnungen anzeigen für:",
  "configuration.dotnet.backgroundAnalysis.compilerDiagnosticsScope.fullSolution": "Gesamte Projektmappe",
  "configuration.dotnet.backgroundAnalysis.compilerDiagnosticsScope.none": "Keine",
  "configuration.dotnet.backgroundAnalysis.compilerDiagnosticsScope.openFiles": "Geöffnete Dokumente",
  "configuration.dotnet.codeLens.enableReferencesCodeLens": "Gibt an, ob die Verweise auf CodeLens angezeigt werden sollen. (Zuvor \"csharp.referencesCodeLens.enabled\")",
  "configuration.dotnet.codeLens.enableTestsCodeLens": "Gibt an, ob der CodeLens-Test zum Ausführen und Debuggen angezeigt werden soll. (Zuvor \"csharp.testsCodeLens.enabled\")",
  "configuration.dotnet.completion.provideRegexCompletions": "Reguläre Ausdrücke in der Vervollständigungsliste anzeigen.",
  "configuration.dotnet.completion.showCompletionItemsFromUnimportedNamespaces": "Ermöglicht die Anzeige nicht importierter Typen und nicht importierter Erweiterungsmethoden in Vervollständigungslisten. Wenn ein Commit ausgeführt wird, wird die entsprechende using-Direktive am Anfang der aktuellen Datei hinzugefügt. (Zuvor \"omnisharp.enableImportCompletion\")",
  "configuration.dotnet.completion.showNameCompletionSuggestions": "Führen Sie die automatische Vervollständigung des Objektnamens für die Elemente aus, die Sie kürzlich ausgewählt haben.",
  "configuration.dotnet.defaultSolution.description": "Der Pfad der Standardlösung, die im Arbeitsbereich geöffnet werden soll, oder auf \"deaktivieren\" festlegen, um sie zu überspringen. (Zuvor \"omnisharp.defaultLaunchSolution\")",
  "configuration.dotnet.dotnetPath": "Gibt den Pfad zu einem dotnet-Installationsverzeichnis an, das anstelle des Standardsystems verwendet werden soll. Dies wirkt sich nur auf die dotnet-Installation aus, die zum Hosten des Sprachservers selbst verwendet werden soll. Beispiel: \"/home/username/mycustomdotnetdirectory\".",
  "configuration.dotnet.highlighting.highlightRelatedJsonComponents": "Zugehörige JSON-Komponenten unter dem Cursor markieren.",
  "configuration.dotnet.highlighting.highlightRelatedRegexComponents": "Zugehörige Komponenten regulärer Ausdrücke unter dem Cursor markieren.",
  "configuration.dotnet.implementType.insertionBehavior": "Die Einfügeposition von Eigenschaften, Ereignissen und Methoden beim Implementieren der Schnittstelle oder abstrakten Klasse.",
  "configuration.dotnet.implementType.insertionBehavior.atTheEnd": "Platzieren Sie sie am Ende.",
  "configuration.dotnet.implementType.insertionBehavior.withOtherMembersOfTheSameKind": "Platzieren Sie sie mit anderen Mitgliedern derselben Art.",
  "configuration.dotnet.implementType.propertyGenerationBehavior": "Generierungsverhalten von Eigenschaften beim Implementieren einer Schnittstelle oder einer abstrakten Klasse.",
  "configuration.dotnet.implementType.propertyGenerationBehavior.preferAutoProperties": "Automatische Eigenschaften bevorzugen.",
  "configuration.dotnet.implementType.propertyGenerationBehavior.preferThrowingProperties": "Ausgelöste Eigenschaften bevorzugen.",
  "configuration.dotnet.inlayHints.enableInlayHintsForLiteralParameters": "Hinweise für Literale anzeigen",
  "configuration.dotnet.inlayHints.enableInlayHintsForObjectCreationParameters": "Hinweise für new-Ausdrücke anzeigen",
  "configuration.dotnet.inlayHints.enableInlayHintsForOtherParameters": "Hinweise für alles andere anzeigen",
  "configuration.dotnet.inlayHints.enableInlayHintsForParameters": "Hinweise zu Inlineparameternamen anzeigen",
  "configuration.dotnet.inlayHints.suppressInlayHintsForParametersThatDifferOnlyBySuffix": "Hinweise unterdrücken, wenn sich Parameternamen nur durch das Suffix unterscheiden",
  "configuration.dotnet.inlayHints.suppressInlayHintsForParametersThatMatchArgumentName": "Hinweise unterdrücken, wenn das Argument mit dem Namen des Parameters übereinstimmt",
  "configuration.dotnet.inlayHints.suppressInlayHintsForParametersThatMatchMethodIntent": "Hinweise unterdrücken, wenn der Parametername mit der Methodenabsicht übereinstimmt",
  "configuration.dotnet.navigation.navigateToDecompiledSources": "Aktivieren der Navigation zu dekompilierten Quellen.",
  "configuration.dotnet.quickInfo.showRemarksInQuickInfo": "Beschreibungsinformationen beim Anzeigen des Symbols anzeigen.",
  "configuration.dotnet.server.extensionPaths": "Außerkraftsetzung für Pfad zu Sprachserver --extension-Argumenten",
  "configuration.dotnet.server.path": "Gibt den absoluten Pfad zur ausführbaren Serverdatei (LSP oder O#) an. Wenn sie leer gelassen wird, wird die an die C#-Erweiterung angeheftete Version verwendet. (Zuvor \"omnisharp.path\")",
  "configuration.dotnet.server.trace": "Legt den Protokolliergrad für den Sprachserver fest.",
  "configuration.dotnet.server.waitForDebugger": "Übergibt das Flag \"--debug\" beim Starten des Servers, damit ein Debugger angefügt werden kann. (Zuvor \"omnisharp.waitForDebugger\")",
  "configuration.dotnet.symbolSearch.searchReferenceAssemblies": "Symbole in Verweisassemblys suchen. Dies wirkt sich auf Features aus, die eine Symbolsuche erfordern, z. B. Importe hinzufügen.",
  "configuration.dotnet.unitTestDebuggingOptions": "Optionen, die mit dem Debugger beim Starten des Komponententestdebuggings verwendet werden können. (Zuvor \"csharp.unitTestDebuggingOptions\")",
  "configuration.razor.languageServer.debug": "Gibt an, ob beim Starten des Sprachservers auf die Debuganfügung gewartet werden soll.",
  "configuration.razor.languageServer.directory": "Überschreibt den Pfad zum Razor-Sprachserver-Verzeichnis.",
  "configuration.razor.trace": "Gibt an, ob alle Nachrichten [Verbose], einige Nachrichten [Messages] oder gar nicht [Off] ausgegeben werden sollen.",
  "configuration.razor.trace.messages": "Protokolliert nur einige Nachrichten von der Razor-Erweiterung.",
  "configuration.razor.trace.off": "Protokolliert keine Nachrichten von der Razor-Erweiterung.",
  "configuration.razor.trace.verbose": "Protokolliert alle Nachrichten aus der Razor-Erweiterung.",
  "debuggers.dotnet.launch.launchConfigurationId.description": "Die zu verwendende Startkonfigurations-ID. Eine leere Zeichenfolge verwendet die aktuelle aktive Konfiguration.",
  "debuggers.dotnet.launch.projectPath.description": "Pfad zur CSPROJ-Datei.",
  "generateOptionsSchema.allowFastEvaluate.description": "Bei \"true\" (Standardzustand) versucht der Debugger eine schnellere Auswertung, indem er die Ausführung einfacher Eigenschaften und Methoden simuliert.",
  "generateOptionsSchema.args.0.description": "Befehlszeilenargumente, die an das Programm übergeben werden.",
  "generateOptionsSchema.args.1.description": "An das Programm übergebene Zeichenfolgenversion von Befehlszeilenargumenten.",
  "generateOptionsSchema.checkForDevCert.description": "Wenn Sie ein Webprojekt unter Windows oder macOS starten und dies aktiviert ist, überprüft der Debugger, ob der Computer über ein selbstsigniertes HTTPS-Zertifikat verfügt, das zum Entwickeln von Webservern verwendet wird, die auf HTTPS-Endpunkten ausgeführt werden. Wenn nicht angegeben, wird standardmäßig \"true\" verwendet, wenn \"serverReadyAction\" festgelegt ist. Mit dieser Option werden keine Linux-, VS Code-Remote- und VS Code-Webbenutzeroberflächenszenarien ausgeführt. Wenn das HTTPS-Zertifikat nicht gefunden wird oder nicht vertrauenswürdig ist, wird der Benutzer aufgefordert, es zu installieren bzw. ihm zu vertrauen.",
  "generateOptionsSchema.console.externalTerminal.enumDescription": "Externes Terminal, das über Benutzereinstellungen konfiguriert werden kann.",
  "generateOptionsSchema.console.integratedTerminal.enumDescription": "Das integrierte Terminal von VS Code.",
  "generateOptionsSchema.console.internalConsole.enumDescription": "Ausgabe an den VS Code-Debugging-Konsole. Das Lesen von Konsoleneingaben (z. B. Console.ReadLine) wird nicht unterstützt.",
  "generateOptionsSchema.console.markdownDescription": "Gibt beim Starten von Konsolenprojekten an, in welcher Konsole das Zielprogramm gestartet werden soll.",
  "generateOptionsSchema.console.settingsDescription": "**Hinweis:** _This Option wird nur für die Debugkonfiguration \"dotnet\" type_ verwendet.\r\n\r\nGibt beim Starten von Konsolenprojekten an, in welcher Konsole das Zielprogramm gestartet werden soll.",
  "generateOptionsSchema.cwd.description": "Pfad zum Arbeitsverzeichnis des Programms, das gedebuggt wird. Der Standardwert ist der aktuelle Arbeitsbereich.",
  "generateOptionsSchema.enableStepFiltering.markdownDescription": "Kennzeichnung zum Aktivieren des Schrittweisen Ausführens von Eigenschaften und Operatoren. Diese Option wird standardmäßig auf \"true\" festgelegt.",
  "generateOptionsSchema.env.description": "Umgebungsvariablen, die an das Programm übergeben werden.",
  "generateOptionsSchema.envFile.markdownDescription": "Umgebungsvariablen, die von einer Datei an das Programm übergeben werden. Beispiel: \"${workspaceFolder}/.env\"",
  "generateOptionsSchema.externalConsole.markdownDescription": "Das Attribut \"externalConsole\" ist veraltet. Verwenden Sie stattdessen \"console\". Diese Option ist standardmäßig auf \"false\" festgelegt.",
  "generateOptionsSchema.justMyCode.markdownDescription": "Wenn diese Option aktiviert ist (Standardeinstellung), wird der Debugger nur angezeigt und in den Benutzercode (\"Mein Code\") eingeschritten. Dabei werden Systemcode und anderer Code ignoriert, der optimiert ist oder über keine Debugsymbole verfügt. [Weitere Informationen](https://aka.ms/VSCode-CS-LaunchJson#just-my-code)",
  "generateOptionsSchema.launchBrowser.args.description": "Die Argumente, die an den Befehl übergeben werden sollen, um den Browser zu öffnen. Dies wird nur verwendet, wenn das plattformspezifische Element (\"osx\", \"linux\" oder \"windows\") keinen Wert für \"args\" angibt. Verwenden Sie ${auto-detect-url}, um automatisch die Adresse zu verwenden, an der der Server lauscht.",
  "generateOptionsSchema.launchBrowser.description": "Beschreibt Optionen zum Starten eines Webbrowsers als Teil des Starts.",
  "generateOptionsSchema.launchBrowser.enabled.description": "Gibt an, ob das Starten des Webbrowsers aktiviert ist. Diese Option wird standardmäßig auf \"true\" festgelegt.",
  "generateOptionsSchema.launchBrowser.linux.args.description": "Die Argumente, die an den Befehl übergeben werden sollen, um den Browser zu öffnen. Verwenden Sie ${auto-detect-url}, um automatisch die Adresse zu verwenden, an der der Server lauscht.",
  "generateOptionsSchema.launchBrowser.linux.command.description": "Die ausführbare Datei, die den Webbrowser startet.",
  "generateOptionsSchema.launchBrowser.linux.description": "Linux-spezifische Optionen für Webstartkonfiguration. Der Browser wird standardmäßig mit \"xdg-open\" gestartet.",
  "generateOptionsSchema.launchBrowser.osx.args.description": "Die Argumente, die an den Befehl übergeben werden sollen, um den Browser zu öffnen. Verwenden Sie ${auto-detect-url}, um automatisch die Adresse zu verwenden, an der der Server lauscht.",
  "generateOptionsSchema.launchBrowser.osx.command.description": "Die ausführbare Datei, die den Webbrowser startet.",
  "generateOptionsSchema.launchBrowser.osx.description": "OSX-spezifische Optionen für Webstartkonfiguration. Der Browser wird standardmäßig mit \"open\" gestartet.",
  "generateOptionsSchema.launchBrowser.windows.args.description": "Die Argumente, die an den Befehl übergeben werden sollen, um den Browser zu öffnen. Verwenden Sie ${auto-detect-url}, um automatisch die Adresse zu verwenden, an der der Server lauscht.",
  "generateOptionsSchema.launchBrowser.windows.command.description": "Die ausführbare Datei, die den Webbrowser startet.",
  "generateOptionsSchema.launchBrowser.windows.description": "Windows-spezifische Optionen für Webstartkonfiguration. Der Browser wird standardmäßig mit \"cmd /c start\" gestartet.",
  "generateOptionsSchema.launchSettingsFilePath.markdownDescription": "Der Pfad zu einer Datei \"launchSettings.json\". Wenn dies nicht festgelegt ist, sucht der Debugger in \"{cwd}/Properties/launchSettings.json\".",
  "generateOptionsSchema.launchSettingsProfile.description": "Gibt bei Angabe den Namen des Profils in \"launchSettings.json\" an, das verwendet werden soll. Dies wird ignoriert, wenn launchSettings.json nicht gefunden wird. \"launchSettings.json\" wird aus dem angegebenen Pfad gelesen. Dabei muss es sich um die Eigenschaft \"launchSettingsFilePath\" oder um {cwd}/Properties/launchSettings.json handeln, wenn dies nicht festgelegt ist. Wenn dieser Wert auf NULL oder eine leere Zeichenfolge festgelegt ist, wird launchSettings.json ignoriert. Wenn dieser Wert nicht angegeben ist, wird das erste Projekt-Profil verwendet.",
  "generateOptionsSchema.logging.browserStdOut.markdownDescription": "Kennzeichnung, um zu bestimmen, ob stdout-Text vom Start des Webbrowsers im Ausgabefenster protokolliert werden soll. Diese Option wird standardmäßig auf \"true\" festgelegt.",
  "generateOptionsSchema.logging.description": "Kennzeichnungen, um zu bestimmen, welche Nachrichtentypen im Ausgabefenster protokolliert werden sollen.",
  "generateOptionsSchema.logging.elapsedTiming.markdownDescription": "Bei \"True\" beinhaltet die Engine-Protokollierung die Eigenschaften \"adapterElapsedTime\" und \"engineElapsedTime\", um anzugeben, wie lange eine Anforderung in Mikrosekunden gedauert hat. Diese Option ist standardmäßig auf \"false\" festgelegt.",
  "generateOptionsSchema.logging.engineLogging.markdownDescription": "Kennzeichnung, um zu bestimmen, ob Protokolle der Diagnose-Engine im Ausgabefenster protokolliert werden sollen. Diese Option ist standardmäßig auf \"false\" festgelegt.",
  "generateOptionsSchema.logging.exceptions.markdownDescription": "Kennzeichnung, um zu bestimmen, ob Ausnahmemeldungen im Ausgabefenster protokolliert werden sollen. Diese Option wird standardmäßig auf \"true\" festgelegt.",
  "generateOptionsSchema.logging.moduleLoad.markdownDescription": "Kennzeichnung, um zu bestimmen, ob Modulladeereignisse im Ausgabefenster protokolliert werden sollen. Diese Option wird standardmäßig auf \"true\" festgelegt.",
  "generateOptionsSchema.logging.processExit.markdownDescription": "Steuert, ob eine Nachricht protokolliert wird, wenn der Zielprozess beendet oder das Debuggen beendet wird. Diese Option wird standardmäßig auf \"true\" festgelegt.",
  "generateOptionsSchema.logging.programOutput.markdownDescription": "Kennzeichnung, um zu bestimmen, ob die Programmausgabe im Ausgabefenster protokolliert werden soll, wenn keine externe Konsole verwendet wird. Diese Option wird standardmäßig auf \"true\" festgelegt.",
  "generateOptionsSchema.logging.threadExit.markdownDescription": "Steuert, ob eine Nachricht protokolliert wird, wenn ein Thread im Zielprozess beendet wird. Diese Option ist standardmäßig auf \"false\" festgelegt.",
  "generateOptionsSchema.pipeTransport.debuggerPath.description": "Der vollständige Pfad zum Debugger auf dem Zielcomputer.",
  "generateOptionsSchema.pipeTransport.description": "Wenn vorhanden, weist dies den Debugger an, eine Verbindung mit einem Remotecomputer mithilfe einer anderen ausführbaren Datei als Pipe herzustellen, die die Standardeingabe/-ausgabe zwischen VS Code und der ausführbaren .NET Core-Debugger-Back-End-Datei (vsdbg) weiterleitet.",
  "generateOptionsSchema.pipeTransport.linux.description": "Linux-spezifische Optionen für Pipestartkonfiguration",
  "generateOptionsSchema.pipeTransport.linux.pipeArgs.0.description": "Befehlszeilenargumente, die an das Pipeprogramm übergeben werden. Token ${debuggerCommand} in pipeArgs wird durch den vollständigen Debuggerbefehl ersetzt. Dieses Token kann inline mit anderen Argumenten angegeben werden. Wenn ${debuggerCommand} in keinem Argument verwendet wird, wird stattdessen der vollständige Debuggerbefehl am Ende der Argumentliste hinzugefügt.",
  "generateOptionsSchema.pipeTransport.linux.pipeArgs.1.description": "Zeichenfolgenversion von Befehlszeilenargumenten, die an das Pipeprogramm übergeben werden. Token ${debuggerCommand} in pipeArgs wird durch den vollständigen Debuggerbefehl ersetzt. Dieses Token kann inline mit anderen Argumenten angegeben werden. Wenn ${debuggerCommand} in keinem Argument verwendet wird, wird stattdessen der vollständige Debuggerbefehl am Ende der Argumentliste hinzugefügt.",
  "generateOptionsSchema.pipeTransport.linux.pipeCwd.description": "Der vollqualifizierte Pfad zum Arbeitsverzeichnis für das Pipeprogramm.",
  "generateOptionsSchema.pipeTransport.linux.pipeEnv.description": "Umgebungsvariablen, die an das Pipeprogramm übergeben werden.",
  "generateOptionsSchema.pipeTransport.linux.pipeProgram.description": "Der vollqualifizierte auszuführende Pipebefehl.",
  "generateOptionsSchema.pipeTransport.linux.quoteArgs.description": "Sollten Argumente, die Zeichen enthalten, die in Anführungszeichen gesetzt werden müssen (Beispiel: Leerzeichen), in Anführungszeichen gesetzt werden? Der Standardwert ist \"true\". Bei Festlegung auf \"false\" wird der Debuggerbefehl nicht mehr automatisch in Anführungszeichen gesetzt.",
  "generateOptionsSchema.pipeTransport.osx.description": "OSX-spezifische Optionen für Pipestartkonfiguration",
  "generateOptionsSchema.pipeTransport.osx.pipeArgs.0.description": "Befehlszeilenargumente, die an das Pipeprogramm übergeben werden. Token ${debuggerCommand} in pipeArgs wird durch den vollständigen Debuggerbefehl ersetzt. Dieses Token kann inline mit anderen Argumenten angegeben werden. Wenn ${debuggerCommand} in keinem Argument verwendet wird, wird stattdessen der vollständige Debuggerbefehl am Ende der Argumentliste hinzugefügt.",
  "generateOptionsSchema.pipeTransport.osx.pipeArgs.1.description": "Zeichenfolgenversion von Befehlszeilenargumenten, die an das Pipeprogramm übergeben werden. Token ${debuggerCommand} in pipeArgs wird durch den vollständigen Debuggerbefehl ersetzt. Dieses Token kann inline mit anderen Argumenten angegeben werden. Wenn ${debuggerCommand} in keinem Argument verwendet wird, wird stattdessen der vollständige Debuggerbefehl am Ende der Argumentliste hinzugefügt.",
  "generateOptionsSchema.pipeTransport.osx.pipeCwd.description": "Der vollqualifizierte Pfad zum Arbeitsverzeichnis für das Pipeprogramm.",
  "generateOptionsSchema.pipeTransport.osx.pipeEnv.description": "Umgebungsvariablen, die an das Pipeprogramm übergeben werden.",
  "generateOptionsSchema.pipeTransport.osx.pipeProgram.description": "Der vollqualifizierte auszuführende Pipebefehl.",
  "generateOptionsSchema.pipeTransport.osx.quoteArgs.description": "Sollten Argumente, die Zeichen enthalten, die in Anführungszeichen gesetzt werden müssen (Beispiel: Leerzeichen), in Anführungszeichen gesetzt werden? Der Standardwert ist \"true\". Bei Festlegung auf \"false\" wird der Debuggerbefehl nicht mehr automatisch in Anführungszeichen gesetzt.",
  "generateOptionsSchema.pipeTransport.pipeArgs.0.description": "Befehlszeilenargumente, die an das Pipeprogramm übergeben werden. Token ${debuggerCommand} in pipeArgs wird durch den vollständigen Debuggerbefehl ersetzt. Dieses Token kann inline mit anderen Argumenten angegeben werden. Wenn ${debuggerCommand} in keinem Argument verwendet wird, wird stattdessen der vollständige Debuggerbefehl am Ende der Argumentliste hinzugefügt.",
  "generateOptionsSchema.pipeTransport.pipeArgs.1.description": "Zeichenfolgenversion von Befehlszeilenargumenten, die an das Pipeprogramm übergeben werden. Token ${debuggerCommand} in pipeArgs wird durch den vollständigen Debuggerbefehl ersetzt. Dieses Token kann inline mit anderen Argumenten angegeben werden. Wenn ${debuggerCommand} in keinem Argument verwendet wird, wird stattdessen der vollständige Debuggerbefehl am Ende der Argumentliste hinzugefügt.",
  "generateOptionsSchema.pipeTransport.pipeCwd.description": "Der vollqualifizierte Pfad zum Arbeitsverzeichnis für das Pipeprogramm.",
  "generateOptionsSchema.pipeTransport.pipeEnv.description": "Umgebungsvariablen, die an das Pipeprogramm übergeben werden.",
  "generateOptionsSchema.pipeTransport.pipeProgram.description": "Der vollqualifizierte auszuführende Pipebefehl.",
  "generateOptionsSchema.pipeTransport.quoteArgs.description": "Sollten Argumente, die Zeichen enthalten, die in Anführungszeichen gesetzt werden müssen (Beispiel: Leerzeichen), in Anführungszeichen gesetzt werden? Der Standardwert ist \"true\". Bei Festlegung auf \"false\" wird der Debuggerbefehl nicht mehr automatisch in Anführungszeichen gesetzt.",
  "generateOptionsSchema.pipeTransport.windows.description": "Windows-spezifische Optionen für Pipestartkonfiguration",
  "generateOptionsSchema.pipeTransport.windows.pipeArgs.0.description": "Befehlszeilenargumente, die an das Pipeprogramm übergeben werden. Token ${debuggerCommand} in pipeArgs wird durch den vollständigen Debuggerbefehl ersetzt. Dieses Token kann inline mit anderen Argumenten angegeben werden. Wenn ${debuggerCommand} in keinem Argument verwendet wird, wird stattdessen der vollständige Debuggerbefehl am Ende der Argumentliste hinzugefügt.",
  "generateOptionsSchema.pipeTransport.windows.pipeArgs.1.description": "Zeichenfolgenversion von Befehlszeilenargumenten, die an das Pipeprogramm übergeben werden. Token ${debuggerCommand} in pipeArgs wird durch den vollständigen Debuggerbefehl ersetzt. Dieses Token kann inline mit anderen Argumenten angegeben werden. Wenn ${debuggerCommand} in keinem Argument verwendet wird, wird stattdessen der vollständige Debuggerbefehl am Ende der Argumentliste hinzugefügt.",
  "generateOptionsSchema.pipeTransport.windows.pipeCwd.description": "Der vollqualifizierte Pfad zum Arbeitsverzeichnis für das Pipeprogramm.",
  "generateOptionsSchema.pipeTransport.windows.pipeEnv.description": "Umgebungsvariablen, die an das Pipeprogramm übergeben werden.",
  "generateOptionsSchema.pipeTransport.windows.pipeProgram.description": "Der vollqualifizierte auszuführende Pipebefehl.",
  "generateOptionsSchema.pipeTransport.windows.quoteArgs.description": "Sollten Argumente, die Zeichen enthalten, die in Anführungszeichen gesetzt werden müssen (Beispiel: Leerzeichen), in Anführungszeichen gesetzt werden? Der Standardwert ist \"true\". Bei Festlegung auf \"false\" wird der Debuggerbefehl nicht mehr automatisch in Anführungszeichen gesetzt.",
  "generateOptionsSchema.processId.0.markdownDescription": "Die Prozess-ID, an die angefügt werden soll. Verwenden Sie \"\", um eine Liste der ausgeführten Prozesse abzurufen, an die angefügt werden soll. Wenn \"processId\" verwendet wird, sollte \"processName\" nicht verwendet werden.",
  "generateOptionsSchema.processId.1.markdownDescription": "Die Prozess-ID, an die angefügt werden soll. Verwenden Sie \"\", um eine Liste der ausgeführten Prozesse abzurufen, an die angefügt werden soll. Wenn \"processId\" verwendet wird, sollte \"processName\" nicht verwendet werden.",
  "generateOptionsSchema.processName.markdownDescription": "Der Prozessname, an den angefügt werden soll. Wenn dies verwendet wird, sollte \"processId\" nicht verwendet werden.",
  "generateOptionsSchema.program.markdownDescription": "Pfad zur Anwendungs-DLL oder ausführbaren .NET Core-Hostdatei, die gestartet werden soll.\r\nDiese Eigenschaft hat normalerweise folgendes Format: \"${workspaceFolder}/bin/Debug/(target-framework)/(project-name.dll)\"\r\n\r\nBeispiel: \"`${workspaceFolder}/bin/Debug/netcoreapp1.1/MyProject.dll`\r\n\r\nWo:\r\n\"(target-framework)\" ist das Framework, für das das debuggte Projekt erstellt wird. Dies wird normalerweise in der Projektdatei als TargetFramework-Eigenschaft gefunden.\r\n\r\n\"(project-name.dll)\" ist der Name der Buildausgabe-DLL des debuggten Projekts. Dies ist normalerweise identisch mit dem Projektdateinamen, aber mit der Erweiterung \".dll\".",
  "generateOptionsSchema.requireExactSource.markdownDescription": "Kennzeichnung, dass der aktuelle Quellcode dem PDB entsprechen muss. Diese Option wird standardmäßig auf \"true\" festgelegt.",
  "generateOptionsSchema.sourceFileMap.markdownDescription": "Ordnet Buildzeitpfade lokalen Quellspeicherorten zu. Alle Instanzen des Buildzeitpfads werden durch den lokalen Quellpfad ersetzt.\r\n\r\nBeispiel:\r\n\r\n'{\"<build-path>\":\"<local-source-path>\"}'",
  "generateOptionsSchema.sourceLinkOptions.additionalItems.enabled.markdownDescription": "Ist Source Link für diese URL aktiviert? Wenn keine Angabe erfolgt, wird diese Option standardmäßig auf \"true\" festgelegt.",
  "generateOptionsSchema.sourceLinkOptions.markdownDescription": "Optionen zum Steuern der Verbindung von Source Link mit Webservern. [Weitere Informationen](https://aka.ms/VSCode-CS-LaunchJson#source-link-options)",
  "generateOptionsSchema.stopAtEntry.markdownDescription": "Bei \"true\" sollte der Debugger am Einstiegspunkt des Ziels beendet werden. Diese Option ist standardmäßig auf \"false\" festgelegt.",
  "generateOptionsSchema.suppressJITOptimizations.markdownDescription": "Bei \"true\" fordert der Debugger den Just-In-Time-Compiler auf, Code mit deaktivierten Optimierungen zu generieren, wenn ein optimiertes Modul (DLL- kompiliert in der Releasekonfiguration) im Zielprozess geladen wird. [Weitere Informationen](https://aka.ms/VSCode-CS-LaunchJson#suppress-jit-optimizations)",
  "generateOptionsSchema.symbolOptions.cachePath.description": "Verzeichnis, in dem von Symbolservern heruntergeladene Symbole zwischengespeichert werden sollen. Wenn nicht angegeben, wird der Debugger unter Windows standardmäßig auf %TEMP%\\SymbolCache festgelegt, und unter Linux und macOS wird der Debugger standardmäßig auf ~/.dotnet/symbolcache festgelegt.",
  "generateOptionsSchema.symbolOptions.description": "Optionen zum Steuern, wie Symbole (PDB-Dateien) gefunden und geladen werden.",
  "generateOptionsSchema.symbolOptions.moduleFilter.description": "Stellt Optionen bereit, um zu steuern, für welche Module (DLL-Dateien) der Debugger versuchen soll, Symbole (PDB-Dateien) zu laden.",
  "generateOptionsSchema.symbolOptions.moduleFilter.excludedModules.description": "Ein Array von Modulen, für das der Debugger keine Symbole laden soll. Platzhalter (Beispiel: MyCompany. *. dll) werden unterstützt.\r\n\r\nDiese Eigenschaft wird ignoriert, wenn „Modus“ nicht auf „loadAllButExcluded“ festgelegt ist.",
  "generateOptionsSchema.symbolOptions.moduleFilter.includeSymbolsNextToModules.description": "Wenn „true“, wird der Debugger für ein beliebiges Modul, das sich NICHT im Array „includedModules“ befindet, weiterhin neben dem Modul selbst und der ausführbaren Datei, die gestartet wird, überprüfen. Die Pfade in der Symbolsuchliste werden jedoch nicht überprüft. Diese Option ist standardmäßig auf „true“ eingestellt.\r\n\r\nDiese Eigenschaft wird ignoriert, wenn „Modus“ nicht auf „loadOnlyIncluded“ festgelegt ist.",
  "generateOptionsSchema.symbolOptions.moduleFilter.includedModules.description": "Ein Array von Modulen, für das der Debugger keine Symbole laden soll. Platzhalter (Beispiel: MyCompany. *. dll) werden unterstützt.\r\n\r\nDiese Eigenschaft wird ignoriert, wenn „Modus“ nicht auf „loadOnlyIncluded“ festgelegt ist.",
  "generateOptionsSchema.symbolOptions.moduleFilter.mode.description": "Steuert, in welchem der beiden grundlegenden Betriebsmodi der Modulfilter ausgeführt wird.",
  "generateOptionsSchema.symbolOptions.moduleFilter.mode.loadAllButExcluded.enumDescription": "Laden Sie Symbole für alle Module, es sei denn, das Modul befindet sich im Array „excludedModules“.",
  "generateOptionsSchema.symbolOptions.moduleFilter.mode.loadOnlyIncluded.enumDescription": "Versuchen Sie nicht, Symbole für IRGENDEIN Modul zu laden, es sei denn, es befindet sich im Array „includedModules“, oder es wird über die Einstellung „includeSymbolsNextToModules“ hinzugefügt.",
  "generateOptionsSchema.symbolOptions.searchMicrosoftSymbolServer.description": "Wenn „true“, wird der Microsoft-Symbolserver (https\u200b://msdl.microsoft.com\u200b/download/symbols) dem Symbolsuchpfad hinzugefügt. Wenn nicht angegeben, wird diese Option standardmäßig auf „false“ eingestellt.",
  "generateOptionsSchema.symbolOptions.searchNuGetOrgSymbolServer.description": "Bei \"true\" wird der NuGet.org-Symbolserver (https:\u200b://symbols.nuget.org\u200b/download/symbols) dem Symbolsuchpfad hinzugefügt. Wenn keine Angabe erfolgt, wird diese Option standardmäßig auf \"false\" festgelegt.",
  "generateOptionsSchema.symbolOptions.searchPaths.description": "Ein Array von Symbolserver-URLs (Beispiel: http\u200b://MyExampleSymbolServer) oder Verzeichnisse (Beispiel:/Build/Symbols) für die Suche nach PDB-Dateien. Diese Verzeichnisse werden zusätzlich zu den Standardspeicherorten durchsucht – neben dem Modul und dem Pfad, in dem die PDB ursprünglich abgelegt wurde.",
  "generateOptionsSchema.targetArchitecture.markdownDescription": "[Nur beim lokalen macOS-Debuggen unterstützt]\r\n\r\nDie Architektur des Debuggens. Dies wird automatisch erkannt, es sei denn, dieser Parameter ist festgelegt. Zulässige Werte sind \"x86_64\" oder \"arm64\".",
  "generateOptionsSchema.targetOutputLogPath.description": "Bei Festlegung wird Text, den die Zielanwendung in \"stdout\" und \"stderr\" (z. B. Console.WriteLine) schreibt, in der angegebenen Datei gespeichert. Diese Option wird ignoriert, wenn die Konsole auf einen anderen Wert als internalConsole festgelegt ist. Beispiel: \"${workspaceFolder}/out.txt\"",
  "viewsWelcome.debug.contents": "[C#-Objekte für Build und Debuggen generieren](command:dotnet.generateAssets)\r\n\r\nWeitere Informationen zu launch.json finden Sie unter [Konfigurieren von launch.json für das C#-Debuggen](https://aka.ms/VSCode-CS-LaunchJson)."
}